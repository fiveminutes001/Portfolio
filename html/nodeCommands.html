<html>
	<head>
		<link href="../css/BasicStyle.css" rel="stylesheet" />
		<link href="../css/TopNav.css" rel="stylesheet" />
		<link href="../css/TopNavbar.css" rel="stylesheet" />
		<link href="../css/contactChip.css" rel="stylesheet" />
	</head>
	<body>
		<!-- prettier-ignore -->
		<div id="mySidenav" class="sidenav">
			<a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
			<a href="#installing">installing</a>
			<a href="#modules">modules</a>
			<a href="#fs">filesystem</a>
			<a href="#processModule">process module</a>
			<a href="#utils">utilities</a>
		</div>
		<div id="main">
			<div class="header">
				<h3>Useful commands</h3>
				<p>with code examples.</p>
			</div>
			<!-- prettier-ignore -->
			<div id="Topnavbar">
				<a href="flexCommands.html">Flex</a>
				<a href="gitCommands.html">Git</a>
				<a class="active" href="javascript:void(0)"><span style="font-size: 16px; cursor: pointer" onclick="openNav()">&#9776; node</span></a>
				<a href="npmCommands.html">npm</a>
			</div>
			<div class="content">
				<div id="navbar"></div>
				<div class="bigChip">
					<img
						src="../img/NodeJs.png"
						alt="NodeJsLogo"
						width="96"
						height="96"
					/>
					node js
				</div>
				<div id="installing" class="headerDiv">
					<h3>Installing node</h3>
				</div>
				<div>
					<h3>To download node</h3>
					<pre>https://nodejs.org</pre>
				</div>
				<div>
					<h3>To check node version</h3>
					<!-- prettier-ignore -->
					<pre>node -v</pre>
				</div>
				<div>
					<h3>To run file</h3>
					<pre>node index.js</pre>
				</div>

				<div id="modules">
					<h3>Modules</h3>
				</div>

				<div>
					<h3>To export functions from module</h3>
					<pre>// exports as object module.exports = {</pre>
					<pre>myFirstFunction: myFirstFunction,</pre>
					<pre>mySecondFunction: mySecondFunction</pre>
					<pre>}</pre>
					<pre>//using ES6 shorthand property names module.exports = {</pre>
					<pre>myFirstFunction,</pre>
					<pre>mySecondFunction</pre>
					<pre>}</pre>
				</div>
				<!-- prettier-ignore -->
				<div>
					<h3>To import functions from module</h3>
					<p class="pink">It is standard to name the const the same as the file or module name.</p>
					<pre>// working file = index.js</pre>
					<pre>// all functions in util/logger.js are available</pre>
					<pre>const logger = require('./util/logger.js');</pre>
					<pre>// using ES6 object destructuring, only myFirstFunction is available</pre>
					<pre> const { myFirstFunction } = require('./util/logger.js');</pre>
				</div>

				<div id="fs">
					<h3>File system</h3>
				</div>
				<div>
					<h3>To get data from the file system</h3>
					<pre>const fs = require('fs');</pre>
				</div>
				<div>
					<h3>To get current directory name/file name</h3>
					<pre>// working file = /app/util/logger.js</pre>
					<pre>console.log(__dirname);</pre>
					<pre>// prints /app/util</pre>
					<pre>console.log(__filename);</pre>
					<pre>// prints /app/util/logger.js</pre>
				</div>
				<!-- prettier-ignore -->
				<div>
					<h3>To get file path</h3>
					<pre>console.log(path.resolve('index.js'));</pre>
					<pre>// prints /Users/user/Desktop/app/index.js</pre>
				</div>
				<div>
					<h3>To get file path with no .</h3>
					<p class="pink">
						Normalizes any path by removing instances of . , turning double
						slashes into single slashes and removing a directory when .. is
						found.
					</p>
					<pre>console.log(path.normalize('./app//src//util/..'));</pre>
					<pre>// prints app/src</pre>
				</div>
				<div>
					<h3>To create path with no .</h3>
					<p class="pink">
						Used to concatenate strings to create a path that works across
						operating systems. It joins the strings, then normalizes the result.
					</p>
					<!-- prettier-ignore -->
					<pre>console.log(path.join('/app', 'src', 'util', '..', '/index.js'));</pre>
					<pre>// prints  /app/src/index.js</pre>
				</div>

				<div>
					<h3>To do things with other core modules</h3>
					<p class="pink">
						HTTP/HTTPS is used to transfer data. Later on, weâ€™ll be using
						Express, which builds on top of this module, to create our server.
					</p>
					<p class="pink">URL is used for parsing and resolving URLs.</p>
					<p class="pink">
						TLS/SSL implements security protocols on top of OpenSSL There are
						more core modules worth checking out in the Node.js documentation.
					</p>
				</div>
				<div id="processModule">
					<h3>Process module</h3>
				</div>
				<div>
					<p class="pink">
						Not found in the browser APIs, Process relates to the global node
						execution process which occurs when you run a js file through
						Node.js. Process has many options available--we will focus on the
						most commonly seen
					</p>
					<h3>process events</h3>
					<p class="pink">
						The Process module contains the ability to perform tasks immediately
						before the process exits, and when it exits. beforeExit allows for
						asynchronous calls which can make the process continue whereas exit
						only happens once all synchronous and asynchronous code is complete.
					</p>
					<pre>// create conditions for exit code options</pre>
					<pre>// example: 0 typically implies without errors, 1 with.</pre>
					<pre>process.exitCode = 1;</pre>
					<pre>process.on('beforeExit', () => {</pre>
					<pre>console.log('beforeExit event');</pre>
					<pre>});</pre>
					<pre>process.on('exit', (code) => {</pre>
					<pre>console.log(`exit event with code: ${code}`);</pre>
					<pre>});</pre>
				</div>
				<div>
					<h3>process.env</h3>
					<p class="pink">
						Process.env gives you access to the environment information of your
						Node.js application. It also allows you to add environment variables
						that can be used if your code is dependent on the environment it is
						run in. With the use of a module like dotenv you can easily control
						your project's configuration in separate .env files based on what
						environment you are using (ex. production vs test vs development).
					</p>
					<p class="pink">
						Common reasons include: changing the port or IP, accessing static
						files, or access to the production vs development databases.
					</p>
					<pre>console.log(process.env);</pre>
				</div>

				<div>
					<h3>process.stdout</h3>
					<p class="pink">
						A lesser-known fact is that console.log actually utilizes
						process.stdout in order to log to the console.
						process.stdout.write('Hello, world.'); and console.log('Hello,
						world.'); are nearly identical except for one very important
						difference, process.stdout does not force a new line break. This
						allows you to create helpful tools like progress bars.
					</p>
				</div>
				<div>
					<h3>process.argv</h3>
					<p class="pink">
						An array containing your console arguments information for your
						executed process.
					</p>
					<p class="pink">
						process.argv allows you to pass in arguments to your application
						which can be a common occurrence when needing to parse data from
						files.
					</p>
					<p class="pink">
						When index.js was run through Node.js, the entire command contained
						four arguments, so the array has four values, the location of
						Node.js on the system, the location of the file run, and then two
						additional arguments.
					</p>
					<p class="pink">
						process.argv allows you to pass in arguments to your application
						which can be a common occurrence when needing to parse data from
						files.
					</p>
					<pre>// index.js</pre>
					<!-- prettier-ignore -->
					<pre>// When run, will output an array of all arguments supplied to the node process.</pre>
					<pre>console.log(process.argv)</pre>
					<pre>// Terminal</pre>
					<pre>$ node index.js argument1 argument2</pre>
					<pre>[</pre>
					<pre>'/usr/local/bin/node',</pre>
					<pre>'/Users/user/Desktop/app/index.js',</pre>
					<pre>'argument1',</pre>
					<pre>'argument2'</pre>
					<pre>]</pre>
				</div>
				<div>
					<h3>process.nextTick</h3>
					<p class="pink">
						Allows you to run JavaScript between the different phases of the
						event loop. process.nextTick will be described in detail when
						discussing the event loop.
					</p>
				</div>
				<div>
					<h3>To schedule events</h3>
					<p class="pink">synchronous - using nothing.</p>
					<p class="pink">setTimeout - assigning to 0 or a second iteration.</p>
					<p class="pink">
						setInterval - could have used a loop of 1 to run one time at 0 or in
						another iteration.
					</p>
					<p class="pink">
						process.nextTick - to run after the synchronous code or after the
						polling phase if used with the file system module.
					</p>
					<p class="pink">
						fs - with synchronous code inside to run after the polling phase.
					</p>
					<p class="pink">
						setImmediate - within fs call to run during the check phase.
					</p>
					<p class="pink">process.on - to run beforeExit or at exit.</p>
				</div>

				<div id="utils">
					<h3>Utilities folder</h3>
				</div>
				<div>
					<h3>To use utilities folder</h3>
					<p class="pink">Create a utilities folder</p>
					<p class="pink">Separate the functions into two files</p>
					<p class="pink">
						use module.exports = { function1, function2 } to export the
						functions.
					</p>
					<p class="pink">
						Import the functions into the index.js file using a module name and
						destructuring. ex: const util = require('utilities/file.js'); or
						const { function1, function2 } = require('utilities/file.js');
					</p>
					<p class="pink">
						Output the results of the functions to console either using the
						function name if you have used destructuring or
						moduleName.functionName if you are calling the module.
					</p>
					<p class="yellow">
						Here is a CJS example using named exports, where util.cjs has an
						export named sum.
					</p>
					<p>
						// @filename: util.cjs <br />
						module.exports.sum = (x, y) => x + y;<br />
						<br />
						// @filename: main.cjs <br />
						const {sum} = require('./util.cjs'); <br />
						console.log(sum(2, 4));
					</p>
					<p class="yellow">
						Here is a CJS example where util.cjs sets a default export. The
						default export has no name; modules using require() define their own
						name.
					</p>
					<p>
						// @filename: util.cjs<br />
						module.exports = (x, y) => x + y; <br />
						<br />
						// @filename: main.cjs<br />
						const whateverWeWant = require('./util.cjs');<br />
						console.log(whateverWeWant(2, 4));
					</p>
					<p class="yellow">
						In ESM scripts, import and export are part of the language; like
						CJS, they have two different syntaxes for named exports and the
						default export. Here’s an ESM example with named exports, where
						util.mjs has an export named sum.
					</p>
					<p>
						// @filename:util.mjs <br />
						export const sum = (x, y) => x + y; <br />
						<br />
						// @filename: main.mjs <br />
						import {sum} from './util.mjs' <br />
						console.log(sum(2, 4)); <br />
					</p>
					<p class="yellow">
						Here is an ESM example where util.mjs sets a default export. Just
						like in CJS, the default export has no name, but the module using
						import defines its own name.
					</p>
					<p>
						// @filename: util.mjs<br />
						export default (x, y) => x + y; <br />
						<br />
						//@filename: main.mjs <br />
						import whateverWeWant from './util.mjs'<br />
						console.log(whateverWeWant(2, 4));<br />
					</p>
				</div>

				<!-- topNav List -->
			</div>
		</div>
		<script src="../js/TopNav.js"></script>
		<script src="../js/TopNavbar.js"></script>
		<script src="../js/BasicJs.js"></script>
	</body>
</html>
